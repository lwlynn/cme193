#include "software_renderer.h"

#include <cmath>
#include <vector>
#include <iostream>
#include <algorithm>
#include <math.h>

#include "triangulation.h"

using namespace std;

namespace CS248 {
    
    
    // Implements SoftwareRenderer //
    
    // fill a sample ind with color
    void SoftwareRendererImp::fill_sample(int sx, int sy, const Color &color) {
        
        // check bounds
        if (sx < 0 || sx >= w) return;
        if (sy < 0 || sy >= h) return;
        
        Color sample_color;
        float inv255 = 1.0 / 255.0;
        
        // sample coordinate --> sample_buffer
        sample_color.r = sample_buffer[4 * (sx + sy * w)] * inv255;
        sample_color.g = sample_buffer[4 * (sx + sy * w) + 1] * inv255;
        sample_color.b = sample_buffer[4 * (sx + sy * w) + 2] * inv255;
        sample_color.a = sample_buffer[4 * (sx + sy * w) + 3] * inv255;
        
        sample_color = ref->alpha_blending_helper(sample_color, color);
        
        sample_buffer[4 * (sx + sy * w)] = (uint8_t)(sample_color.r * 255);
        sample_buffer[4 * (sx + sy * w) + 1] = (uint8_t)(sample_color.g * 255);
        sample_buffer[4 * (sx + sy * w) + 2] = (uint8_t)(sample_color.b * 255);
        sample_buffer[4 * (sx + sy * w) + 3] = (uint8_t)(sample_color.a * 255);
        
    }
    
    // fill samples in the entire pixel specified by pixel coordinates
    void SoftwareRendererImp::fill_pixel(int x, int y, const Color &color) {
        /* All fill_pixel should do is fill all the samples in the pixel located at (x, y) with Color. For example, if your sampling rate is 4, you should figure out what are the 4 slots in the supersample_buffer that correspond to the pixel at (x, y) and fill out all the 4 slots with the Color. */
        
        // Task 2: Re-implement this function
        
        // check bounds
        if (x < 0 || x >= target_w) return;
        if (y < 0 || y >= target_h) return;
        
        // pixel coordinates to sample coordinate
        for (int i = x * sample_rate; i< x * sample_rate + sample_rate;i++){
            for (int j = y * sample_rate; j< y * sample_rate + sample_rate;j++){
                fill_sample(i, j, color);
            }
        }
    }
    
    void SoftwareRendererImp::draw_svg( SVG& svg ) {
        
        // set top level transformation: converts from the svg canvas' coordinate system to screen coordinates
        transformation = canvas_to_screen;
        
        // draw all elements
        for ( size_t i = 0; i < svg.elements.size(); ++i ) {
            draw_element(svg.elements[i]);
        }
        
        // draw canvas outline
        Vector2D a = transform(Vector2D(    0    ,     0    )); a.x--; a.y--;
        Vector2D b = transform(Vector2D(svg.width,     0    )); b.x++; b.y--;
        Vector2D c = transform(Vector2D(    0    ,svg.height)); c.x--; c.y++;
        Vector2D d = transform(Vector2D(svg.width,svg.height)); d.x++; d.y++;
        
        rasterize_line(a.x, a.y, b.x, b.y, Color::Black);
        rasterize_line(a.x, a.y, c.x, c.y, Color::Black);
        rasterize_line(d.x, d.y, b.x, b.y, Color::Black);
        rasterize_line(d.x, d.y, c.x, c.y, Color::Black);
        
        // resolve and send to render target
        resolve();
        
    }
    
    void SoftwareRendererImp::set_sample_rate( size_t sample_rate ) {
        /* In response to the user changing the screen sampling rate (the = and - keys), the application will call set_sample_rate(). */
        
        // Task 2:
        // You may want to modify this for supersampling support
        this->sample_rate = sample_rate;
        
        /// renew the sample buffer
        clear_target();
        w = target_w * sample_rate;
        h = target_h * sample_rate;
        sample_buffer.resize(w * h * 4); // each sample has four color channels
        fill(sample_buffer.begin(),sample_buffer.end(),255);
        
        
    }
    
    void SoftwareRendererImp::set_render_target( unsigned char* render_target,
                                                size_t width, size_t height ) {
        /* set_render_target() is called whenever the user resizes the application window. */
        
        // Task 2:
        // You may want to modify this for supersampling support
        clear_target();
        this->render_target = render_target;
        this->target_w = width;
        this->target_h = height;
        
        // renew the sample buffer
        w = width * sample_rate;
        h = height * sample_rate;
        sample_buffer.resize(w * h * 4); // each sample has four color channels
        fill(sample_buffer.begin(),sample_buffer.end(),255);

    }
    
    
    
    
    void SoftwareRendererImp::draw_element( SVGElement* element ) {
        
        /* This function inspects the type of the element, and then calls the appropriate draw function */
        
        // Task 3 (part 1):
        // Modify this to implement the transformation stack
        Matrix3x3 transformation0 = transformation;
        transformation = transformation * element->transform;
        
        switch (element->type) {
            case POINT:
                draw_point(static_cast<Point&>(*element));
                break;
            case LINE:
                draw_line(static_cast<Line&>(*element));
                break;
            case POLYLINE:
                draw_polyline(static_cast<Polyline&>(*element));
                break;
            case RECT:
                draw_rect(static_cast<Rect&>(*element));
                break;
            case POLYGON:
                draw_polygon(static_cast<Polygon&>(*element));
                break;
            case ELLIPSE:
                draw_ellipse(static_cast<Ellipse&>(*element));
                break;
            case IMAGE:
                draw_image(static_cast<Image&>(*element));
                break;
            case GROUP:
                draw_group(static_cast<Group&>(*element));
                break;
            default:
                break;
        }
        transformation = transformation0;
        
    }
    
    
    // Primitive Drawing //
    
    void SoftwareRendererImp::draw_point( Point& point ) {
        // transforms the input point into its screen-space position
        Vector2D p = transform(point.position);
        rasterize_point( p.x, p.y, point.style.fillColor );
        
    }
    
    void SoftwareRendererImp::draw_line( Line& line ) {
        
        Vector2D p0 = transform(line.from);
        Vector2D p1 = transform(line.to);
        rasterize_line( p0.x, p0.y, p1.x, p1.y, line.style.strokeColor );
        
    }
    
    void SoftwareRendererImp::draw_polyline( Polyline& polyline ) {
        
        Color c = polyline.style.strokeColor;
        
        if( c.a != 0 ) {
            int nPoints = polyline.points.size();
            for( int i = 0; i < nPoints - 1; i++ ) {
                Vector2D p0 = transform(polyline.points[(i+0) % nPoints]);
                Vector2D p1 = transform(polyline.points[(i+1) % nPoints]);
                rasterize_line( p0.x, p0.y, p1.x, p1.y, c );
            }
        }
    }
    
    void SoftwareRendererImp::draw_rect( Rect& rect ) {
        
        Color c;
        
        // draw as two triangles
        float x = rect.position.x;
        float y = rect.position.y;
        float w = rect.dimension.x;
        float h = rect.dimension.y;
        
        Vector2D p0 = transform(Vector2D(   x   ,   y   ));
        Vector2D p1 = transform(Vector2D( x + w ,   y   ));
        Vector2D p2 = transform(Vector2D(   x   , y + h ));
        Vector2D p3 = transform(Vector2D( x + w , y + h ));
        
        // draw fill
        c = rect.style.fillColor;
        if (c.a != 0 ) {
            rasterize_triangle( p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, c );
            rasterize_triangle( p2.x, p2.y, p1.x, p1.y, p3.x, p3.y, c );
        }
        
        // draw outline
        c = rect.style.strokeColor;
        if( c.a != 0 ) {
            rasterize_line( p0.x, p0.y, p1.x, p1.y, c );
            rasterize_line( p1.x, p1.y, p3.x, p3.y, c );
            rasterize_line( p3.x, p3.y, p2.x, p2.y, c );
            rasterize_line( p2.x, p2.y, p0.x, p0.y, c );
        }
        
    }
    
    void SoftwareRendererImp::draw_polygon( Polygon& polygon ) {
        
        Color c;
        
        // draw fill
        c = polygon.style.fillColor;
        if( c.a != 0 ) {
            
            // triangulate
            vector<Vector2D> triangles;
            triangulate( polygon, triangles );
            
            // draw as triangles
            for (size_t i = 0; i < triangles.size(); i += 3) {
                Vector2D p0 = transform(triangles[i + 0]);
                Vector2D p1 = transform(triangles[i + 1]);
                Vector2D p2 = transform(triangles[i + 2]);
                rasterize_triangle( p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, c );
            }
        }
        
        // draw outline
        c = polygon.style.strokeColor;
        if( c.a != 0 ) {
            int nPoints = polygon.points.size();
            for( int i = 0; i < nPoints; i++ ) {
                Vector2D p0 = transform(polygon.points[(i+0) % nPoints]);
                Vector2D p1 = transform(polygon.points[(i+1) % nPoints]);
                rasterize_line( p0.x, p0.y, p1.x, p1.y, c );
            }
        }
    }
    
    void SoftwareRendererImp::draw_ellipse( Ellipse& ellipse ) {
        
        // Extra credit
        
    }
    
    void SoftwareRendererImp::draw_image( Image& image ) {
        
        Vector2D p0 = transform(image.position);
        Vector2D p1 = transform(image.position + image.dimension);
        
        rasterize_image( p0.x, p0.y, p1.x, p1.y, image.tex );
    }
    
    void SoftwareRendererImp::draw_group( Group& group ) {
        
        for ( size_t i = 0; i < group.elements.size(); ++i ) {
            draw_element(group.elements[i]);
        }
        
    }
    
    // Rasterization //
    
    // The input arguments in the rasterization functions
    // below are all defined in screen space coordinates
    
    void SoftwareRendererImp::rasterize_point( float x, float y, Color color ) {
        
        // fill in the nearest pixel
        int sx = (int)floor(x);
        int sy = (int)floor(y);
        
        // check bounds
        if (sx < 0 || sx >= target_w) return;
        if (sy < 0 || sy >= target_h) return;
        
        // fill sample - NOT doing alpha blending!
        // TODO: Call fill_pixel here to run alpha blending
//        render_target[4 * (sx + sy * target_w)] = (uint8_t)(color.r * 255);
//        render_target[4 * (sx + sy * target_w) + 1] = (uint8_t)(color.g * 255);
//        render_target[4 * (sx + sy * target_w) + 2] = (uint8_t)(color.b * 255);
//        render_target[4 * (sx + sy * target_w) + 3] = (uint8_t)(color.a * 255);
//
        fill_pixel(sx,sy,color);
        
    }
    
    void SoftwareRendererImp::rasterize_line( float x0, float y0,
                                             float x1, float y1,
                                             Color color) {
        
        // Extra credit (delete the line below and implement your own)
        ref->rasterize_line_helper(x0, y0, x1, y1, target_w, target_h, color, this);
        
    }
    
    // point in triangle test
    bool insideTri(float x, float y, float sx0, float sy0, float sx1, float sy1, float sx2, float sy2){
        
        float nx0, nx1, nx2, ny0, ny1, ny2; // normals
        float dx0, dx1, dx2, dy0, dy1, dy2; // directions
        
        // directions
        dx0 = sx1 - sx0;
        dy0 = sy1 - sy0;
        
        // normals
        nx0 = sy1 - sy0;
        ny0 = sx1 - sx1;
        
        float tx0 = sx2 - sx0;
        float ty0 = sy2 - sy0;
        
        if((nx0*tx0+ny0*ty0)<=0){
            if((x-sx0)*nx0+(y-sy0)*ny0<=0) return true;
            else return false;
        }
        else{
            if((x-sx0)*nx0+(y-sy0)*ny0<0) return false;
            else return true;
        }
        
    }
    
    //x,y: pixel index
    void samplesInThePixel(int x, int y, vector<int> &SIdxXs,vector<int> &SIdxYs, int sample_rate){

        for (int i = 0;i< sample_rate;i++){
            for (int j = 0; j< sample_rate;j++){
                SIdxXs.push_back(x * sample_rate+i);
                SIdxYs.push_back(y * sample_rate+j);
            }
        }
    }
    
    void SoftwareRendererImp::rasterize_triangle( float x0, float y0,
                                                 float x1, float y1,
                                                 float x2, float y2,
                                                 Color color ) {
        
        // Task 1:
        // Implement triangle rasterization (you may want to call fill_sample here) //???
        
        // fill in the nearest pixel // int vs. float???
        int px0 = (int)floor(x0);
        int py0 = (int)floor(y0);
        int px1 = (int)floor(x1);
        int py1 = (int)floor(y1);
        int px2 = (int)floor(x2);
        int py2 = (int)floor(y2);
        
        // bounding box : pixel idx
        int xmin = min(min(px0, px1),px2);
        int ymin = min(min(py0, py1),py2);
        int xmax = max(max(px0, px1),px2);
        int ymax = max(max(py0, py1),py2);
        
        // pixel loc
        for(int x=xmin; x<=xmax; x++){
            for(int y=ymin; y<=ymax; y++){
                
                // find all samples loc in this pixel
                vector<int> SIdxXs;
                vector<int> SIdxYs;
                samplesInThePixel(x, y,SIdxXs,SIdxYs,sample_rate);
                
                // check if this sample in triangle
                for (int k =0 ;k<SIdxXs.size();k++){
                    // convert to sample middle point coordinate
                    float sx= (SIdxXs[k]*1. + 0.5)/sample_rate;
                    float sy= (SIdxYs[k]*1. + 0.5)/sample_rate;
                    if(insideTri(sx, sy, x0, y0, x1, y1, x2, y2) && insideTri(sx, sy, x1, y1, x2, y2, x0, y0) && insideTri(sx, sy, x2, y2, x0, y0, x1, y1)){
                        fill_sample(SIdxXs[k],SIdxYs[k],color);
                    }
                }
            }
        }// end of xmin
        
    }
    
    
    void SoftwareRendererImp::rasterize_image( float x0, float y0,
                                              float x1, float y1,
                                              Texture& tex ) {
        // Task 4:
        // Implement image rasterization (you may want to call fill_sample here)
        
        // fill in the nearest pixel // int vs. float???
        int px0 = (int)floor(x0);
        int py0 = (int)floor(y0);
        int px1 = (int)floor(x1);
        int py1 = (int)floor(y1);
        
        // pixel loc
        for(int x=px0; x<=px1; x++){
            for(int y=py0; y<=py1; y++){

                // find all samples loc in this pixel
                vector<int> SIdxXs;
                vector<int> SIdxYs;
                samplesInThePixel(x, y,SIdxXs,SIdxYs,sample_rate);

                // check if each sample in the image
                for (int k =0 ;k<SIdxXs.size();k++){

                    // convert to sample middle point coordinate
                    float sx_mid= (SIdxXs[k]*1. + 0.5)/sample_rate;
                    float sy_mid= (SIdxYs[k]*1. + 0.5)/sample_rate;

                    // in the image
                    if (sx_mid>=x0 && sx_mid<=x1 && sy_mid >=y0 && sy_mid <=y1){
                        float u = (sx_mid-x0)/(x1-x0);
                        float v = (sy_mid-y0)/(y1-y0);
                        Color c1 = this->sampler->sample_bilinear(tex,u,v,0);
                        fill_sample(SIdxXs[k],SIdxYs[k],c1);
                    }else{
                        fill_sample(SIdxXs[k],SIdxYs[k],Color(255,255,255,255));
                    }
                }
            }
        }
        
    }
    
 
    // resolve samples to render target
    void SoftwareRendererImp::resolve( ) {
        
        // Task 2:
        // Implement supersampling
        // You may also need to modify other functions marked with "Task 2".
        
        // pixel index
        float inv255 = 1.0 / 255.0;
        int samplePerPixel= pow(sample_rate,2);
        for (int x = 0; x< target_w;x++){
            for (int y = 0;y< target_h; y++){
                Color pixel_color;
                float r =0.; float g =0.; float b =0.; float a =0.;
                
                // convert pixel_loc(idx) to sample_idx
                for (int i0 = x * sample_rate; i0< x * sample_rate + sample_rate;i0++){
                    for (int j0 = y * sample_rate; j0< y * sample_rate + sample_rate;j0++){
                        
                        // convert loc to sample_buffer
                        r += sample_buffer[4 * (i0+j0 * w)] * inv255;
                        g += sample_buffer[4 * (i0+j0 * w) + 1] * inv255;
                        b += sample_buffer[4 * (i0+j0 * w) + 2] * inv255;
                        a += sample_buffer[4 * (i0+j0 * w) + 3] * inv255;
                    }
                }
                //corresponding to sample buffer ind ind given pixel location
                
                pixel_color.r = r / samplePerPixel;
                pixel_color.g = g / samplePerPixel;
                pixel_color.b = b / samplePerPixel;
                pixel_color.a = a / samplePerPixel;
                
                render_target[4 * (x + y * target_w)] = (uint8_t)(pixel_color.r * 255);
                render_target[4 * (x + y * target_w) + 1] = (uint8_t)(pixel_color.g* 255);
                render_target[4 * (x + y * target_w) + 2] = (uint8_t)(pixel_color.b* 255);
                render_target[4 * (x + y * target_w) + 3] = (uint8_t)(pixel_color.a* 255);
                
                
            }
        }
        
        this->sample_buffer.resize(w * h * 4); // each sample has four color channels
        fill(this->sample_buffer.begin(),this->sample_buffer.end(),255);
        return;
        
    }
    
    
} // namespace CS248
